---
title:      "算法"
date:       2018-06-28 12:00:00
categories:
- 算法
tags:
    - 算法
---

# 查找算法

## 顺序查找

* 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。
* 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。
* 算法复杂度：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ；当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。
* 实现代码

~~~c
#include <stdio.h>


int find_intvalue(int array[], int value, int n)
{
  int i;
  for (i = 0; i < n; i++) {
    if (array[i] == value) {
      return i;
    }
  }
  return -1;
}


int main()
{
  int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int value = 4;
  int ind;
  ind = find_intvalue(a, value, 10);
  printf("%d", ind);
  return 0;
}

~~~

## 二分查找
* 说明：元素必须是有序的，如果是无序的则要先进行排序操作。
* 基本思想：也称为是折半查找，属于有序查找算法。
* 复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
* 实现代码

~~~c
#include <stdio.h>

int binary_find(int array[], int va, int len)
{
  int low, high, middle;
  low = 0;
  high = len - 1;
  while (low <= high) {
    middle = (low + high) / 2;
    if (array[middle] > va) {
      high = middle+1;
    } else if (array[middle] == va)
    {
      return middle;
    } else {
      low = middle-1;
    }
  }
  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = binary_find(array,va,6);
  printf("%d",ind);
  return -1;
}
~~~

## 插值查找
* 基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。
* 复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。
* 实现代码

~~~c
#include <stdio.h>

int binary_find(int array[], int va, int len)
{
  int low, high, middle;
  low = 0;
  high = len - 1;
  float tmp;
  while (low <= high) {
    tmp = ((va - array[low])*1.0 / (array[high] - array[low])) * (high - low);
    middle = low + (int)tmp;
    if (array[middle] == va)
      return middle;
    if (array[middle] < va)
      low = middle-1;
    if (array[middle] > va)
      high = middle+1;
  }
  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = binary_find(array, va, 6);
  printf("%d", ind);
  return 0;
}
~~~

## 斐波那契查找
* 复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。
* 斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。
* 实现代码

~~~c
#include <stdio.h>

int MAX_SIZE = 50;

void init_fibonacci(int f[])
{
  int i;
  f[0] = 1;
  f[1] = 1;
  for (i = 2; i < MAX_SIZE; i++)
    f[i] = f[i - 1] + f[i - 2];
}

int fibonacci_search(int array[], int va, int len)
{
  int low, high, middle;
  int k, i;
  int tmp[MAX_SIZE];

  high = len - 1;
  k = 0;
  low = 0;

  int F[MAX_SIZE];
  init_fibonacci(F);
  while (len > (F[k] - 1))
    k++;

  for (i = 0; i < len; i++)
    tmp[i] = array[i];

  for (i = len; i < (F[k] - 1); i++)
    tmp[i] = array[high];

  while (low <= high)
  {
    middle = low + F[k - 1] - 1;
    if (tmp[middle] == va)
      if (middle < len)
        return middle;
      else
        return len - 1;
    if (tmp[middle] < va)
    { 
      low = middle + 1; 
      k -= 2;
    }
    if (tmp[middle] > va)
    { 
      high = middle - 1; 
      k -= 1;
    }
  }

  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = fibonacci_search(array, va, 6);
  printf("%d\n", ind);
  return 0;
}
~~~

## 二叉树查找
* 它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。
* 基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 
* 代码实现：

~~~c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 10

typedef struct binary_node{
  int value;
  struct binary_node* left;
  struct binary_node* right;
}bin_node;


void insert_node(bin_node* root,bin_node* child)
{
  if (child->value >= root->value && root->right != NULL)
  {
    insert_node(root->right,child);
  }
  if (child->value < root->value && root->left != NULL)
  {
    insert_node(root->left,child);
  }
  if (child->value >= root->value && root->right == NULL)
  {
    root->right = child;
  }
  if (child->value < root->value && root->left == NULL)
  {
    root->left = child;
  }
}

void create_tree(bin_node** root, int array[], int size)
{
  int i;
  *root = (bin_node*)malloc(sizeof(bin_node)); 
  (*root)->value = array[0];
  (*root)->left = NULL;
  (*root)->right = NULL;
  for (i=1; i<size;i++)
  {
    bin_node* child = (bin_node*)malloc(sizeof(bin_node));
    child->value = array[i];
    child->left = NULL;
    child->right = NULL;
    insert_node(*root,child);
  }
}

void dis_node(bin_node* node)
{
  if (node == NULL)
    return;
  if (node->left != NULL)
  {
    dis_node(node->left);
  }
  printf("%d ",node->value);
  if (node->right != NULL)
  {
    dis_node(node->right);
  }
}

bin_node* search_node(bin_node* node, int value)
{
  if (node == NULL)
  {
    return NULL;
  }
  if (value == node->value)
  {
    return node;
  }
  if (value > node->value)
  {
    return search_node(node->right,value);
  }
  if (value < node->value)
  {
    return search_node(node->left,value);
  }
  return NULL;
}


int main()
{
  int array[SIZE] = {4,1,45,78,345,23,12,3,6,21};
  bin_node* root = NULL;
  bin_node* search_result = NULL;
  int search_value;
  create_tree(&root,array,SIZE);
  dis_node(root);
  printf("\nPlease input value to search:");
  scanf("%d",&search_value);
  search_result = search_node(root,search_value);
  if (search_result != NULL)
  {
    printf("Yes\n")&;
  }
  else
  {
    printf("No\n");
  }
  return 0;
}
~~~

## 2-3查找树
* 在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN
* 在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
* 代码就不用实现了，因为维护代价比较大，不适用
* 原理: [link](https://blog.csdn.net/u014688145/article/details/67636509)

## 红黑查找树
* 是2-3树的一种实现。
* 原理：[link](https://blog.csdn.net/u014688145/article/details/68489582)
* 代码实现：

~~~c
#include<stdio.h>
#include<stdlib.h>

#define RED   'R'
#define BLACK 'B'


typedef struct Node {
    int          key;
    char         color;
    struct Node *left;
    struct Node *right;
    struct Node *parent;
} Node;

// Based on CLRS algorithm, use T_Nil as a sentinel to simplify code
struct Node  T_Nil_Node;
Node* T_Nil = &T_Nil_Node;

Node* Root = NULL;

// A utility function to create a new BST node
Node* newNode(int key)
{
    Node *temp   = (Node*) malloc(sizeof(Node));
    temp->key    = key;
    temp->color  = RED;
    temp->left   = NULL;
    temp->right  = NULL;
    temp->parent = NULL;

    return temp;
}

void rotateLeft( Node** T, Node* x)
{
    Node *y  = x->right;    // set y
    x->right = y->left;     // turn y's left subtree into x's right subtree{
    if (y->left != T_Nil)
        y->left->parent = x;
    y->parent = x->parent;  // link x's parent to y
    if (x->parent == T_Nil)
        *T = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;
    y->left   = x;            // put x on y's left
    x->parent = y;
}

void rotateRight(Node** T, Node* y)
{
    Node *x  = y->left;     // set x
    y->left  = x->right;    // turn x's right subtree into y's left subtree{
    if (x->right != T_Nil)
        x->right->parent = y;
    x->parent = y->parent;  // link y's parent to x
    if (y->parent == T_Nil)
        *T = x;
    else if (y == y->parent->right)
        y->parent->right = x;
    else
        y->parent->left  = x;
    x->right  = y;         // put y on x's right
    y->parent = x;
}

void redBlackInsertFixup(Node** Root, Node* New)
{
    Node* temp;
    while (New->parent->color == RED)
    {
        if (New->parent == New->parent->parent->left)
        {
            temp = New->parent->parent->right;
            if (temp->color == RED)
            {
                New->parent->color = BLACK;
                temp->color = BLACK;
                New->parent->parent->color = RED;
                New = New->parent->parent;
            }
            else {
                if (New == New->parent->right)
                {
                    New = New->parent;
                    rotateLeft(Root, New);
                }
                New->parent->color = BLACK;
                New->parent->parent->color = RED;
                rotateRight(Root, New->parent->parent);
            }
        }
        else
        {
            temp = New->parent->parent->left;
            if (temp->color == RED)
            {
                New->parent->color = BLACK;
                New->color = BLACK;
                New->parent->parent->color = RED;
                New = New->parent->parent;
            }
            else {
                if (New == New->parent->left)
                {
                    New = New->parent;
                    rotateRight(Root, New);
                }
                New->parent->color = BLACK;
                New->parent->parent->color = RED;
                rotateLeft(Root, New->parent->parent);
            }
        }
    }
    Root[0]->color = BLACK;
}
void redBlackInsert(Node** T, int key)
{
    Node* z =  newNode(key);
    Node* y =  T_Nil;
    Node* x = *T;

    // Find where to Insert new node Z into the binary search tree
    while (x != T_Nil) {
        y = x;
        if (z->key < x->key)
            x = x->left;
        else
            x = x->right;
    }

    z->parent = y;
    if (y == T_Nil)
        *T = z;
    else if (z->key < y->key)
        y->left  = z;
    else
        y->right = z;

    // Init z as a red leaf
    z->left  = T_Nil;
    z->right = T_Nil;
    z->color = RED;

    // Ensure the Red-Black property is maintained
    redBlackInsertFixup(T, z);
}

#define MAX(a,b) (((a)>(b))?(a):(b))

int height(Node* Root)
{
    int h = 0;

    if (Root != NULL) {
        if (Root == T_Nil)
            h = 1;
        else
        {
            int leftHeight  = height(Root->left);
            int rightHeight = height(Root->right);
            h = MAX(leftHeight, rightHeight) + 1;
        }
    }

    return h;
}

//中序遍历
void printTree(Node* root)
{
    if (root->left != T_Nil)
        printTree(root->left);
    printf("%d ", root->key);
    if (root->right != T_Nil)
        printTree(root->right);
}

int main(int argc, char* argv[])
{
    Node* Root = T_Nil;
    int list[10] = {1, 3, 2, 5, 4, 7, 6, 9, 8, 10};
    for (int i = 0; i < 10; i++)
    {
        //printf("%d ", list[i]);
        redBlackInsert(&Root, list[i]);
    }
    printTree(Root);
}
~~~

## 分块查找
* 分块查找又称索引顺序查找，它是顺序查找的一种改进方法。
* 算法思想：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素。
* 性能在顺序查找和二分查找之间:
* 实现代码(这种方法不够自动):

~~~c
#include<iostream>
using namespace std;
 
#define MAX 16
 
typedef int key_type;
 
struct elem
{
  key_type key; //关键字 
};
 
//索引结构 
struct index         
{
  key_type key; //索引值 
  long low;     //起始位置 
  long high;    //终止位置 
};
 
int index_search(elem e[], key_type key, int n, index idx[], int idx_length)
{
  int low = 0;
  int high = idx_length - 1;
  int mid;
  
  //采用折半查找在索引表里找到关键字所在的块
  while(low <= high)
  {
    mid = (low + high)/2;
    if(key < idx[mid].key)
      high = mid - 1;
    else if(key > idx[mid].key)
      low = mid + 1;
         else
      break;
  } 
  
  //采用顺序查找的方法从块中查找关键值
  int i = idx[mid].low;
  
  while(i <= idx[mid].high && e[i].key != key)
  {
    i++;
  } 
  
  if(i > idx[mid].high)
    return -1;
  else
    return i;
}
 
 
int main(int argc, char** argv)
{
  elem linelist[MAX] = {
    8, 20, 13, 17,
    40, 42, 45, 32,
    49, 58, 50, 52,
    67, 79, 78, 80
  };
  
  int n = sizeof(linelist) / sizeof(elem);
  key_type key = 50;
  
  //建立索引表
  index index_table[4] = {
      {20,0,3}, 
      {45,4,7}, 
      {58,8,11}, 
      {80,12,15}}; 
  int idx_length = sizeof(index_table) / sizeof(index);
  
  printf("线性表中的元素为：\n");
 
  int i = 0;
  
  while(i < n) 
  {
    printf("%d\n",linelist[i].key);
    i++;
  }
  
  printf("\n关键字[%d]在线性表中的位置下标为[%d]", key, index_search(linelist, key, n, index_table, idx_length));
  
  getchar();
  system("pause");
}
~~~

## HASH查找
* 通过函数实现KV查找,用空间代替时间
* HASH构造方法: [link](https://blog.csdn.net/tanggao1314/article/details/51457585)

# 动态规划
## 含义
* 动态规划算法的核心就是记住已经解决过的子问题的解。
* 两种方法: ①自顶向下的备忘录法 ②自底向上。
* [讲解](https://blog.csdn.net/u013309870/article/details/75193592)

## 自顶向下的备忘录法
~~~c
#include <iostream>
using namespace std;


int fib(int n,int *Memo)
{
    if(Memo[n]!=-1)
        return Memo[n];
    //如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。               
    if(n<=2)
        Memo[n]=1;
    else 
        Memo[n]=fib( n-1,Memo)+fib(n-2,Memo);  
    return Memo[n];
}
int Fibonacci(int n)
{
    if(n<=0)
        return n;
    int *Memo=new int(n+1);        
    for(int i=0;i<=n;i++)
         Memo[i]=-1;
    return fib(n, Memo);
}

int main(){
    cout << Fibonacci(6) << endl;
    return 0;
}
~~~
备忘录法也是比较好理解的，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。比如上面的递归树中在计算fib（6）的时候先计算fib（5），调用fib（5）算出了fib（4）后，fib（6）再调用fib（4）就不会在递归fib（4）的子树了，因为fib（4）的值已经保存在Memo[4]中。

## 自底向上
~~~c
public static int fib(int n)
{
  if(n<=1)
    return n;

  int Memo_i_2=0;
  int Memo_i_1=1;
  int Memo_i=1;
  for(int i=2;i<=n;i++)
  {
    Memo_i=Memo_i_2+Memo_i_1;
    Memo_i_2=Memo_i_1;
    Memo_i_1=Memo_i;
  }       
  return Memo_i;
}
~~~
一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。 

## 例题
### 钢条切割
* 递归

~~~c
#include <iostream>
using namespace std;

int cut(int *p, int n)
{
    if (n==0)
        return 0;
    int q=-10;
    int m;
    for (int i=1;i<=n;++i)
    {
        m = cut(p,n-i);
        if (q<(p[i-1]+m))
            q = p[i-1]+m;
    }
    return q;
}

int main()
{
    int p[]={1,5,8,9,10,17,17,20,24,30};
    cout << cut(p, 9);
}
~~~
把每个子最优解返回到父最优解

* 备忘

~~~c
#include <iostream>
using namespace std;

int cut(int *r, int *p, int n)
{
    int q = -1;
    int m;
    if (n==0)
        return 0;
    if (r[n-1] != -1)
        return r[n-1];
    for (int i=1;i<=n;i++)
    {
        m = p[i-1]+cut(r,p,n-i);
        if (m>q)
            q = m;
    }
    r[n-1] = q;
    return q;
}

int cut_pre(int *p, int n)
{
    int *r = new int(n);
    for (int i=0;i<n;i++)
        r[i] = -1;
    return cut(r, p, n);
}

int main()
{
    // 每长度对应的价值
    int p[]={1,5,8,9,10,17,17,20,24,30};
    // 9为长度
    cout << cut_pre(p, 9);
}
~~~

* 自底向上

~~~c
#include <iostream>
using namespace std;

int cut(int *p, int n)
{
    int *r = new int(n+1);
    int q, m;
    for (int i=0;i<n+1;i++)
    {
        r[i] = 0;
    }
    for (int i=1;i<=n;i++)
    {
        q = -1;
        for (int j=1;j<=i;j++)
        {
            m = p[j-1]+r[i-j];
            if (m>q)
                q = m;
        }
        r[i] = q;
    }
    return r[n];
}

int main()
{
    // 每长度对应的价值
    int p[]={1,5,8,9,10,17,17,20,24,30};
    // 9为长度
    cout << cut(p, 9);
}
~~~
通过求解最优子问题来解决副问题的最优解

## 在什么地方用？
### 最优子结构
用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。

### 重叠子问题
在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。

## 动态规划的经典模型

### 线性模型
线性模型的是动态规划中最常用的模型，上文讲到的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。

例：在一个夜黑风高的晚上，有n（n <= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。

*分析*:
我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i]        (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)
如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2*a[2]    (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题),所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2*a[2] }

~~~c
#include <iostream>
using namespace std;

int go(int *cost_time, int n)
{
    int *r = new int(n);
    int m,mb;
    r[0] = cost_time[0];
    r[1] = cost_time[1];
    for (int i=2;i<n;i++)
    {
        m = r[i-1]+cost_time[0]+cost_time[i];
        mb = r[i-2]+cost_time[0]+cost_time[i]+2*cost_time[1];
        if (m>mb)
            r[i] = mb;
        else
            r[i] = m;
    }
    return r[n-1];
}

int main()
{
    // 每个人过桥花费的时间
    int cost_time[] = {1,2,5,10};
    cout << go(cost_time,4) << endl;
}
~~~

### 区间模型
区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。

例:给定一个长度为n（n <= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 

~~~c
#include <iostream>
using namespace std;

int cacu(char *a, int start, int end, int re[6][6]);

int main()
{
    char *a = "cccbccc";
    int re[6][6];
    cout << cacu(a, 0, 6, re) << endl;
}

int cacu(char *a, int start, int end, int re[6][6])
{
    int m, n;
    if (start+1 >= end || start >= end-1)
        return 0;
    if (a[start] == a[end])
        return cacu(a, start+1, end-1, re);
    m = cacu(a, start+1, end, re);
    n = cacu(a, start, end-1, re);
    if (m>n)
        re[start][end] = n+1;
    else
        re[start][end] = m+1;
    return re[start][end];
}
~~~

### 01背包问题
给定背包的大小，给定物品的价值和重量，确定能够装下的最大价值。

~~~c
#include <iostream>
#include <cstring>
using namespace std;

const int N=15;
 
int main()
{
  int v[N]={0,8,10,6,3,7,2};
  int w[N]={0,4,6,2,2,5,1};
  int m[N][N];
  int n=6,c=12;
  memset(m,0,sizeof(m));
  for(int i=1;i<=n;i++)
  {
    for(int j=1;j<=c;j++)
    {
      if(j>=w[i])
        m[i][j]=max(m[i-1][j],m[i-1][j-w[i]]+v[i]);
      else
        m[i][j]=m[i-1][j];
    }
  }
  cout << m[n][c] << endl;
  return 0;
}
~~~


# 其他

## 字符串查找算法
### 传统的字符串匹配算法:

~~~c
void find(char t[],char p[]){
    int m = strlen(t);
    int n = strlen(p);
    int i,j,k;//k:匹配串下标，j：模式串下标
    for(k=0;k<m;k++){
        j = 0;
        i = k;
        while(j<n){
            if(p[j]==t[i]){
                i++;
                j++;
            }else{
                break;
            }
        }
        if(j==n){
            printf("在%d处匹配\n",k);
            break;
        }
    }
}
~~~

### *KMP*算法
  * [详解](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

~~~c
#include<iostream>
#include<string.h>
#include<vector>
using namespace std;

int kmp(const string &T, const string &P) {
  if (P.empty()) return 0;

  vector<int> pi(P.size(), 0);
  cout << "---" << pi.size() << "---" << endl;
  for (int i = 1, k = 0; i < P.size(); ++i) {
    while (k && P[k] != P[i]) k = pi[k - 1];
    if (P[k] == P[i]) ++k;
    pi[i] = k;
  }
  for (int i=0;i<pi.size();i++)
    cout << pi[i];
  cout << endl;


  for (int i = 0, k = 0; i < T.size(); ++i) {
    while (k && P[k] != T[i]) k = pi[k - 1];
    if (P[k] == T[i]) ++k;
    if (k == P.size()) return i - k + 1;
  }

  return -1;
}


int main()
{
  string T = "abcdefgadbcabcd";
  string P = "ccadaddd";
  cout << kmp(T, P);
  return 0;
}
~~~
