<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title>DDS学习</title>
      <url>/ros/2018/07/14/dds/</url>
      <content type="text">DDS学习

概念
DDS以数据为中心的发布一订阅模型为所有分布式节点之间建立了一个虚拟共享的“全局数据空间(Global Data Space, GDS)。在该模型下分布式节点在网络上以发布或订阅的方式传输数据，节点可以是发布者或订阅者，或者既是发布者又是订阅者。网络中的数据对象用主题((Topic)做标识，分布式节点在全局数据空间中发布或订阅感兴趣的主题信息。各个节点在逻辑上无主从关系，点与点之间都是对等关系.通信方式可以是点对点、点对多、多对多等，在QoS的控制下建立连接，自动发现和配置网络参数,如下图


DDS架构

DDS规范有两层，分别是数据本地重构层DLRL（Data Local Reconstruction Layer)和以数据为中心的发布一订阅层DCPS（Data-Centric Publish-Subscribe）。DCPS层是DDS的核心和基础，提供了通信的基本服务；DLRL层将DCPS层提供的服务进行了抽象，在DLRL层建立了与底层服务的映射关系。

DDS域（Domain）和域参与者（Domain Participant）


DDS组成模型
DDS内所有的成员都是Entity，DDS中的任两个Entity（实体角色）通信都必须在同一个Domain内进行交互，即他们初始化时DomainID是同一个，并且不同Domain的DomainID必须唯一。Domain内的DomainParticipant是服务的入口点，任何DDS应用都需首先获取DomainParticipant，然后通过Domain Participant获取其他服务，如Publisher、Subscriber、Topic等。


几个重要概念

  服务质量策略(QoS)。DDS规范定义了丰富的服务质量策略(Quality of Services Policies)，QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，DDS定义QoS策略使其对复杂网络环境的适应性和鲁棒性大大增强，优化网络传输质量。QoS可以理解为数据提供者和接收者之间的合约。

  Domain是一个范围概念，由域号(DomainID ) 唯一标示，只有在同一个域内的通信实体才能通信，不同域内的实体间无任何逻辑关系。
  Domain Participant作为数据分发服务的入口点，包含若干发布者、订阅者和注册主题，负责创建、删除和管理这些实体。
  Publisher作为发布者角色，至少包含一个DataWriter，并负责创建、删除和管理DataWriter。同样，Subscribe作为订阅角色，至少与一个DataReader关联，并负责创建、删除和管理DataReader。
  DataWriter具体负责发布数据，数据发布者通过调用DataWriter的write函数发布数据，但数据不会立刻被送出，实际的消息产生是通过Puhlisher和QoS综合控制的。
  DataReader负责订阅数据，订阅方式可采用异步方式(Listener)、同步方式(WaitSet)和非阻塞三种。
  Topic是DataWriter和DataReader相互通信时约定的主题，每个DataWriter/DataReader必须与一个主题绑定，相互通信的DataWriter与DataReader之间的主题数据类型必须相同、QoS必须匹配。另外，Topic必须有确定的数据类型。


DDS官方文档阅读

  The purpose of the DDS specification can be summarized as enabling the “Efficient and Robust Delivery of the Right
Information to the Right Place at the Right Time.”


补充
OMG IDL Stubs and Skeletons(IDL stubs and skeletons serve as a “glue” between the client and servants, respectively, and the ORB),IDL Compiler(An IDL compiler transforms OMG IDL definitions into stubs and skeletons),Dynamic Invocation Interface(Dynamic Invocation Interface (DII): The DII allows clients to generate requests at run-time), Dynamic Skeleton Interface(The DSI allows an ORB to deliver requests to servants that have no compile-time knowledge of the IDL interface they implement), Object Adapter(Object Adapters enable ORBs to support various types of servants that possess similar requirements),Interface Repository(The Interface Repository provides run-time information about IDL interfaces),Implementation Repository(The Implementation Repository contains information that allows an ORB to activate servers to process servants).

CORBA适用场景：RPC-style applications that possess “best-effort” quality of service (QoS) requirements.
CORBA不适用场景： high-performance, real-time applications for the fol- lowing reasons.
REASON:(1)Lack of QoS specification interfaces;(2)Lack of QoS enforcement;(3)Lack of real-time programming features:(4)Lack of performance optimizations;(5)

文档阅读


  各膜的全称及作用
  1.1 AMQP: The Advanced Message Queuing Protocol
   作用: designed to address applications requiring fast and reliable business transactions.
  1.2 JMS: Java Message Service API
   作用:  designed to address applications requiring fast and reliable business transactions, JMS is focused on Java-centric systems
  1.3 MQTT:  Message Queuing Telemetry Transport 
   作用: provides a simple and lightweight device data collection solution
  1.4 REST: Representational state transfer
   作用:  provides a simple client-server (request/reply) style of communications that is useful for systems that need to communicate over the Internet, but it cannot provide asynchronous loosely coupled publish-and-subscribe message exchanges. 
ahdjkahsdjhajkshdfjkhajkdfhakhfjkhajskdhfkashkdfhkasdfasd


7/29任务
消息中间件，实时系统，嵌入式，AI算子，
嵌入式,嵌入式

  Dr. Basel Halak: link
    
      嵌入式教授
      关注嵌入式安全和功耗
    
  
  Professor Bashir Al-Hashimi: link
    
      嵌入式教授，比较牛
      关注嵌入式系统中的低功耗，如实时系统中的低功耗，关系power-efficient的论文较多
    
  


Real-time比较
TAO为满足QoS所做的操作：

  高速网路适配器：一个或多个ATM接口控制器芯片(APIC)互相连接而组成的菊花链 .APIC能作为一个系统/网络接口使用，也能作为I/O接口芯片组使用.
  实时I/O系统：通过避免优先级倒置来提高实时性，用一个核心线程池专用处理协议并且用应用程序的线程关联这些线程. 这些核心线程运行在与应用程序线程同样的优先级别, 这样能防止多种实时调度事故的发生如优先反演和隐藏调度.
  实时调度:TAO通过支持周期性实时应用程序的实时I/O调度类来确保支持QoS. 一旦实时I/O类的一个线程被操作系统接纳, 调度程序将负责(1) 计算在类中相关的其它线程的优先级并且(2)周期性地分发这些线程以使它们在最后期限是满足的.
  输入控制器:输入控制允许操作系统要么确保指定的计算时间，要么拒绝接收线程. 输入控制对于实时系统在确定和统计QoS需求方面很有用处.
  实时对象适配器:TAO使用de-分层多路分解 (Figure 4(B)).这种近似使用多路分解键(demultiplexing keys)的方式把ORB指派给客户端. 这些键映射客户请求到对象/操作在O(1)时间里不需要任何的哈西运算或搜索.
img


</content>
      <categories>
        
          <category> ros </category>
        
      </categories>
      <tags>
        
          <tag> ros </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>查找算法</title>
      <url>/%E7%AE%97%E6%B3%95/2018/06/28/alg/</url>
      <content type="text">查找算法

顺序查找


  说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。
  基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。
  算法复杂度：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ；当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。
  实现代码


#include &amp;lt;stdio.h&amp;gt;


int find_intvalue(int array[], int value, int n)
{
  int i;
  for (i = 0; i &amp;lt; n; i++) {
    if (array[i] == value) {
      return i;
    }
  }
  return -1;
}


int main()
{
  int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int value = 4;
  int ind;
  ind = find_intvalue(a, value, 10);
  printf(&quot;%d&quot;, ind);
  return 0;
}




二分查找

  说明：元素必须是有序的，如果是无序的则要先进行排序操作。
  基本思想：也称为是折半查找，属于有序查找算法。
  复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；
  实现代码


#include &amp;lt;stdio.h&amp;gt;

int binary_find(int array[], int va, int len)
{
  int low, high, middle;
  low = 0;
  high = len - 1;
  while (low &amp;lt;= high) {
    middle = (low + high) / 2;
    if (array[middle] &amp;gt; va) {
      high = middle+1;
    } else if (array[middle] == va)
    {
      return middle;
    } else {
      low = middle-1;
    }
  }
  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = binary_find(array,va,6);
  printf(&quot;%d&quot;,ind);
  return -1;
}



插值查找

  基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。
  复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。
  实现代码


#include &amp;lt;stdio.h&amp;gt;

int binary_find(int array[], int va, int len)
{
  int low, high, middle;
  low = 0;
  high = len - 1;
  float tmp;
  while (low &amp;lt;= high) {
    tmp = ((va - array[low])*1.0 / (array[high] - array[low])) * (high - low);
    middle = low + (int)tmp;
    if (array[middle] == va)
      return middle;
    if (array[middle] &amp;lt; va)
      low = middle-1;
    if (array[middle] &amp;gt; va)
      high = middle+1;
  }
  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = binary_find(array, va, 6);
  printf(&quot;%d&quot;, ind);
  return 0;
}



斐波那契查找

  复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。
  斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。
  实现代码


#include &amp;lt;stdio.h&amp;gt;

int MAX_SIZE = 50;

void init_fibonacci(int f[])
{
  int i;
  f[0] = 1;
  f[1] = 1;
  for (i = 2; i &amp;lt; MAX_SIZE; i++)
    f[i] = f[i - 1] + f[i - 2];
}

int fibonacci_search(int array[], int va, int len)
{
  int low, high, middle;
  int k, i;
  int tmp[MAX_SIZE];

  high = len - 1;
  k = 0;
  low = 0;

  int F[MAX_SIZE];
  init_fibonacci(F);
  while (len &amp;gt; (F[k] - 1))
    k++;

  for (i = 0; i &amp;lt; len; i++)
    tmp[i] = array[i];

  for (i = len; i &amp;lt; (F[k] - 1); i++)
    tmp[i] = array[high];

  while (low &amp;lt;= high)
  {
    middle = low + F[k - 1] - 1;
    if (tmp[middle] == va)
      if (middle &amp;lt; len)
        return middle;
      else
        return len - 1;
    if (tmp[middle] &amp;lt; va)
    { 
      low = middle + 1; 
      k -= 2;
    }
    if (tmp[middle] &amp;gt; va)
    { 
      high = middle - 1; 
      k -= 1;
    }
  }

  return -1;
}

int main()
{
  int array[6] = {1, 2, 3, 4, 5, 6};
  int va = 5;
  int ind;
  ind = fibonacci_search(array, va, 6);
  printf(&quot;%d\n&quot;, ind);
  return 0;
}



二叉树查找

  它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。
  基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。
  代码实现：


#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;

#define RED   'R'
#define BLACK 'B'


typedef struct Node {
    int          key;
    char         color;
    struct Node *left;
    struct Node *right;
    struct Node *parent;
} Node;

// Based on CLRS algorithm, use T_Nil as a sentinel to simplify code
struct Node  T_Nil_Node;
Node* T_Nil = &amp;amp;T_Nil_Node;

Node* Root = NULL;

// A utility function to create a new BST node
Node* newNode(int key)
{
    Node *temp   = (Node*) malloc(sizeof(Node));
    temp-&amp;gt;key    = key;
    temp-&amp;gt;color  = RED;
    temp-&amp;gt;left   = NULL;
    temp-&amp;gt;right  = NULL;
    temp-&amp;gt;parent = NULL;

    return temp;
}

void rotateLeft( Node** T, Node* x)
{
    Node *y  = x-&amp;gt;right;    // set y
    x-&amp;gt;right = y-&amp;gt;left;     // turn y's left subtree into x's right subtree{
    if (y-&amp;gt;left != T_Nil)
        y-&amp;gt;left-&amp;gt;parent = x;
    y-&amp;gt;parent = x-&amp;gt;parent;  // link x's parent to y
    if (x-&amp;gt;parent == T_Nil)
        *T = y;
    else if (x == x-&amp;gt;parent-&amp;gt;left)
        x-&amp;gt;parent-&amp;gt;left = y;
    else
        x-&amp;gt;parent-&amp;gt;right = y;
    y-&amp;gt;left   = x;            // put x on y's left
    x-&amp;gt;parent = y;
}

void rotateRight(Node** T, Node* y)
{
    Node *x  = y-&amp;gt;left;     // set x
    y-&amp;gt;left  = x-&amp;gt;right;    // turn x's right subtree into y's left subtree{
    if (x-&amp;gt;right != T_Nil)
        x-&amp;gt;right-&amp;gt;parent = y;
    x-&amp;gt;parent = y-&amp;gt;parent;  // link y's parent to x
    if (y-&amp;gt;parent == T_Nil)
        *T = x;
    else if (y == y-&amp;gt;parent-&amp;gt;right)
        y-&amp;gt;parent-&amp;gt;right = x;
    else
        y-&amp;gt;parent-&amp;gt;left  = x;
    x-&amp;gt;right  = y;         // put y on x's right
    y-&amp;gt;parent = x;
}

void redBlackInsertFixup(Node** Root, Node* New)
{
    Node* temp;
    while (New-&amp;gt;parent-&amp;gt;color == RED)
    {
        if (New-&amp;gt;parent == New-&amp;gt;parent-&amp;gt;parent-&amp;gt;left)
        {
            temp = New-&amp;gt;parent-&amp;gt;parent-&amp;gt;right;
            if (temp-&amp;gt;color == RED)
            {
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                temp-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                New = New-&amp;gt;parent-&amp;gt;parent;
            }
            else {
                if (New == New-&amp;gt;parent-&amp;gt;right)
                {
                    New = New-&amp;gt;parent;
                    rotateLeft(Root, New);
                }
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                rotateRight(Root, New-&amp;gt;parent-&amp;gt;parent);
            }
        }
        else
        {
            temp = New-&amp;gt;parent-&amp;gt;parent-&amp;gt;left;
            if (temp-&amp;gt;color == RED)
            {
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                New = New-&amp;gt;parent-&amp;gt;parent;
            }
            else {
                if (New == New-&amp;gt;parent-&amp;gt;left)
                {
                    New = New-&amp;gt;parent;
                    rotateRight(Root, New);
                }
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                rotateLeft(Root, New-&amp;gt;parent-&amp;gt;parent);
            }
        }
    }
    Root[0]-&amp;gt;color = BLACK;
}
void redBlackInsert(Node** T, int key)
{
    Node* z =  newNode(key);
    Node* y =  T_Nil;
    Node* x = *T;

    // Find where to Insert new node Z into the binary search tree
    while (x != T_Nil) {
        y = x;
        if (z-&amp;gt;key &amp;lt; x-&amp;gt;key)
            x = x-&amp;gt;left;
        else
            x = x-&amp;gt;right;
    }

    z-&amp;gt;parent = y;
    if (y == T_Nil)
        *T = z;
    else if (z-&amp;gt;key &amp;lt; y-&amp;gt;key)
        y-&amp;gt;left  = z;
    else
        y-&amp;gt;right = z;

    // Init z as a red leaf
    z-&amp;gt;left  = T_Nil;
    z-&amp;gt;right = T_Nil;
    z-&amp;gt;color = RED;

    // Ensure the Red-Black property is maintained
    redBlackInsertFixup(T, z);
}

//中序遍历
void printTree(Node* root)
{
    if (root-&amp;gt;left != T_Nil)
        printTree(root-&amp;gt;left);
    printf(&quot;%d &quot;, root-&amp;gt;key);
    if (root-&amp;gt;right != T_Nil)
        printTree(root-&amp;gt;right);
}

void findNode(Node* root,int key)
{
    if (root-&amp;gt;key == key)
    {
        printf(&quot;\nYes\n&quot;);
        return;
    }
    else
    {
        if (root-&amp;gt;key &amp;gt; key)
            if (root-&amp;gt;left != T_Nil)
                findNode(root-&amp;gt;left,key);
            else
                return;
        else
            if (root-&amp;gt;right != T_Nil)
                findNode(root-&amp;gt;right,key);
            else
                return;
    }
}

int main(int argc, char* argv[])
{
    Node* Root = T_Nil;
    int list[10] = {1, 3, 2, 5, 4, 7, 6, 9, 8, 10};
    for (int i = 0; i &amp;lt; 10; i++)
    {
        //printf(&quot;%d &quot;, list[i]);
        redBlackInsert(&amp;amp;Root, list[i]);
    }
    printTree(Root);
    findNode(Root,8);
}



2-3查找树

  在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN
  在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN
  代码就不用实现了，因为维护代价比较大，不适用
  原理: link


红黑查找树

  是2-3树的一种实现。
  原理：link
  代码实现：


#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;

#define RED   'R'
#define BLACK 'B'


typedef struct Node {
    int          key;
    char         color;
    struct Node *left;
    struct Node *right;
    struct Node *parent;
} Node;

// Based on CLRS algorithm, use T_Nil as a sentinel to simplify code
struct Node  T_Nil_Node;
Node* T_Nil = &amp;amp;T_Nil_Node;

Node* Root = NULL;

// A utility function to create a new BST node
Node* newNode(int key)
{
    Node *temp   = (Node*) malloc(sizeof(Node));
    temp-&amp;gt;key    = key;
    temp-&amp;gt;color  = RED;
    temp-&amp;gt;left   = NULL;
    temp-&amp;gt;right  = NULL;
    temp-&amp;gt;parent = NULL;

    return temp;
}

void rotateLeft( Node** T, Node* x)
{
    Node *y  = x-&amp;gt;right;    // set y
    x-&amp;gt;right = y-&amp;gt;left;     // turn y's left subtree into x's right subtree{
    if (y-&amp;gt;left != T_Nil)
        y-&amp;gt;left-&amp;gt;parent = x;
    y-&amp;gt;parent = x-&amp;gt;parent;  // link x's parent to y
    if (x-&amp;gt;parent == T_Nil)
        *T = y;
    else if (x == x-&amp;gt;parent-&amp;gt;left)
        x-&amp;gt;parent-&amp;gt;left = y;
    else
        x-&amp;gt;parent-&amp;gt;right = y;
    y-&amp;gt;left   = x;            // put x on y's left
    x-&amp;gt;parent = y;
}

void rotateRight(Node** T, Node* y)
{
    Node *x  = y-&amp;gt;left;     // set x
    y-&amp;gt;left  = x-&amp;gt;right;    // turn x's right subtree into y's left subtree{
    if (x-&amp;gt;right != T_Nil)
        x-&amp;gt;right-&amp;gt;parent = y;
    x-&amp;gt;parent = y-&amp;gt;parent;  // link y's parent to x
    if (y-&amp;gt;parent == T_Nil)
        *T = x;
    else if (y == y-&amp;gt;parent-&amp;gt;right)
        y-&amp;gt;parent-&amp;gt;right = x;
    else
        y-&amp;gt;parent-&amp;gt;left  = x;
    x-&amp;gt;right  = y;         // put y on x's right
    y-&amp;gt;parent = x;
}

void redBlackInsertFixup(Node** Root, Node* New)
{
    Node* temp;
    while (New-&amp;gt;parent-&amp;gt;color == RED)
    {
        if (New-&amp;gt;parent == New-&amp;gt;parent-&amp;gt;parent-&amp;gt;left)
        {
            temp = New-&amp;gt;parent-&amp;gt;parent-&amp;gt;right;
            if (temp-&amp;gt;color == RED)
            {
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                temp-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                New = New-&amp;gt;parent-&amp;gt;parent;
            }
            else {
                if (New == New-&amp;gt;parent-&amp;gt;right)
                {
                    New = New-&amp;gt;parent;
                    rotateLeft(Root, New);
                }
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                rotateRight(Root, New-&amp;gt;parent-&amp;gt;parent);
            }
        }
        else
        {
            temp = New-&amp;gt;parent-&amp;gt;parent-&amp;gt;left;
            if (temp-&amp;gt;color == RED)
            {
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                New = New-&amp;gt;parent-&amp;gt;parent;
            }
            else {
                if (New == New-&amp;gt;parent-&amp;gt;left)
                {
                    New = New-&amp;gt;parent;
                    rotateRight(Root, New);
                }
                New-&amp;gt;parent-&amp;gt;color = BLACK;
                New-&amp;gt;parent-&amp;gt;parent-&amp;gt;color = RED;
                rotateLeft(Root, New-&amp;gt;parent-&amp;gt;parent);
            }
        }
    }
    Root[0]-&amp;gt;color = BLACK;
}
void redBlackInsert(Node** T, int key)
{
    Node* z =  newNode(key);
    Node* y =  T_Nil;
    Node* x = *T;

    // Find where to Insert new node Z into the binary search tree
    while (x != T_Nil) {
        y = x;
        if (z-&amp;gt;key &amp;lt; x-&amp;gt;key)
            x = x-&amp;gt;left;
        else
            x = x-&amp;gt;right;
    }

    z-&amp;gt;parent = y;
    if (y == T_Nil)
        *T = z;
    else if (z-&amp;gt;key &amp;lt; y-&amp;gt;key)
        y-&amp;gt;left  = z;
    else
        y-&amp;gt;right = z;

    // Init z as a red leaf
    z-&amp;gt;left  = T_Nil;
    z-&amp;gt;right = T_Nil;
    z-&amp;gt;color = RED;

    // Ensure the Red-Black property is maintained
    redBlackInsertFixup(T, z);
}

#define MAX(a,b) (((a)&amp;gt;(b))?(a):(b))

int height(Node* Root)
{
    int h = 0;

    if (Root != NULL) {
        if (Root == T_Nil)
            h = 1;
        else
        {
            int leftHeight  = height(Root-&amp;gt;left);
            int rightHeight = height(Root-&amp;gt;right);
            h = MAX(leftHeight, rightHeight) + 1;
        }
    }

    return h;
}

//中序遍历
void printTree(Node* root)
{
    if (root-&amp;gt;left != T_Nil)
        printTree(root-&amp;gt;left);
    printf(&quot;%d &quot;, root-&amp;gt;key);
    if (root-&amp;gt;right != T_Nil)
        printTree(root-&amp;gt;right);
}

int main(int argc, char* argv[])
{
    Node* Root = T_Nil;
    int list[10] = {1, 3, 2, 5, 4, 7, 6, 9, 8, 10};
    for (int i = 0; i &amp;lt; 10; i++)
    {
        //printf(&quot;%d &quot;, list[i]);
        redBlackInsert(&amp;amp;Root, list[i]);
    }
    printTree(Root);
}



分块查找

  分块查找又称索引顺序查找，它是顺序查找的一种改进方法。
  算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素。
  性能在顺序查找和二分查找之间:
  实现代码(这种方法不够自动):


#include&amp;lt;iostream&amp;gt;
using namespace std;
 
#define MAX 16
 
typedef int key_type;
 
struct elem
{
  key_type key; //关键字 
};
 
//索引结构 
struct index         
{
  key_type key; //索引值 
  long low;     //起始位置 
  long high;    //终止位置 
};
 
int index_search(elem e[], key_type key, int n, index idx[], int idx_length)
{
  int low = 0;
  int high = idx_length - 1;
  int mid;
  
  //采用折半查找在索引表里找到关键字所在的块
  while(low &amp;lt;= high)
  {
    mid = (low + high)/2;
    if(key &amp;lt; idx[mid].key)
      high = mid - 1;
    else if(key &amp;gt; idx[mid].key)
      low = mid + 1;
         else
      break;
  } 
  
  //采用顺序查找的方法从块中查找关键值
  int i = idx[mid].low;
  
  while(i &amp;lt;= idx[mid].high &amp;amp;&amp;amp; e[i].key != key)
  {
    i++;
  } 
  
  if(i &amp;gt; idx[mid].high)
    return -1;
  else
    return i;
}
 
 
int main(int argc, char** argv)
{
  elem linelist[MAX] = {
    8, 20, 13, 17,
    40, 42, 45, 32,
    49, 58, 50, 52,
    67, 79, 78, 80
  };
  
  int n = sizeof(linelist) / sizeof(elem);
  key_type key = 50;
  
  //建立索引表
  index index_table[4] = {
      {20,0,3}, 
      {45,4,7}, 
      {58,8,11}, 
      {80,12,15}}; 
  int idx_length = sizeof(index_table) / sizeof(index);
  
  printf(&quot;线性表中的元素为：\n&quot;);
 
  int i = 0;
  
  while(i &amp;lt; n) 
  {
    printf(&quot;%d\n&quot;,linelist[i].key);
    i++;
  }
  
  printf(&quot;\n关键字[%d]在线性表中的位置下标为[%d]&quot;, key, index_search(linelist, key, n, index_table, idx_length));
  
  getchar();
  system(&quot;pause&quot;);
}



HASH查找

  通过函数实现KV查找,用空间代替时间
  HASH构造方法: link


</content>
      <categories>
        
          <category> 算法 </category>
        
      </categories>
      <tags>
        
          <tag> 算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>gdb调试</title>
      <url>/%E5%B7%A5%E5%85%B7/2018/06/27/gdb/</url>
      <content type="text">gdb调试

gcc -g  main.c                      //在目标文件加入源代码的信息
gdb a.out       

(gdb) start                         //开始调试
(gdb) n                             //一条一条执行
(gdb) step/s                        //执行下一条，如果函数进入函数
(gdb) backtrace/bt                  //查看函数调用栈帧
(gdb) info/i locals                 //查看当前栈帧局部变量
(gdb) frame/f                       //选择栈帧，再查看局部变量
(gdb) print/p                       //打印变量的值
(gdb) finish                        //运行到当前函数返回
(gdb) set var sum=0                 //修改变量值
(gdb) list/l 行号或函数名             //列出源码
(gdb) display/undisplay sum         //每次停下显示变量的值/取消跟踪
(gdb) break/b  行号或函数名           //设置断点
(gdb) continue/c                    //连续运行
(gdb) info/i breakpoints            //查看已经设置的断点
(gdb) delete breakpoints 2          //删除某个断点
(gdb) disable/enable breakpoints 3  //禁用/启用某个断点
(gdb) break 9 if sum != 0           //满足条件才激活断点
(gdb) run/r                         //重新从程序开头连续执行
(gdb) watch input[4]                //设置观察点
(gdb) info/i watchpoints            //查看设置的观察点
(gdb) x/7b input                    //打印存储器内容，b--每个字节一组，7--7组
(gdb) disassemble                   //反汇编当前函数或指定函数
(gdb) si                            // 一条指令一条指令调试 而 s 是一行一行代码
(gdb) info registers                // 显示所有寄存器的当前值
(gdb) x/20 $esp                    //查看内存中开始的20个数


</content>
      <categories>
        
          <category> 工具 </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>k8s 1.10集群deploy</title>
      <url>/k8s/2018/06/11/k8s1.10/</url>
      <content type="text">k8s 1.10搭建问题

master节点


  将etcd  etcdctl  kube-apiserver  kube-controller-manager  kubectl  kube-scheduler二进制文件复制到master节点


详细请点击


  k8s 1.10 安装


k8s 1.10 容器化组件

  等待

</content>
      <categories>
        
          <category> k8s </category>
        
      </categories>
      <tags>
        
          <tag> k8s </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>sublime text 3安装</title>
      <url>/%E5%B7%A5%E5%85%B7/2018/06/09/sublime/</url>
      <content type="text">
  “sublime text 3安装“


问题

sublime text 3 mac下的安装，

软件下载

去百度云或者官网

修改host文件

vim /etc/hosts
//加入下面的类容
127.0.0.1       www.sublimetext.com
127.0.0.1       license.sublimehq.com


输入key

----- BEGIN LICENSE -----
sgbteam
Single User License
EA7E-1153259
8891CBB9 F1513E4F 1A3405C1 A865D53F
115F202E 7B91AB2D 0D2A40ED 352B269B
76E84F0B CD69BFC7 59F2DFEF E267328F
215652A3 E88F9D8F 4C38E3BA 5B2DAAE4
969624E7 DC9CD4D5 717FB40C 1B9738CF
20B3C4F1 E917B5B3 87C38D9C ACCE7DD8
5F7EF854 86B9743C FADC04AA FB0DA5C0
F913BE58 42FEA319 F954EFDD AE881E0B
------ END LICENSE ------



安装package control

ctrl+` 后输入
import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)



安装插件

markdown插件
MarkdownEditing: 修改用户设置(GFM)，修改为下列配置文件（先把default复制到user）
// Layout
&quot;draw_centered&quot;: true,
&quot;word_wrap&quot;: true,
&quot;wrap_width&quot;: 120,
&quot;rulers&quot;: [],



MarkdownPreview: 配合上一个插件用

格式化代码相关
CodeFormatter: 格式化代码，有几种语言不支持
CoolFormat: 格式化代码
Alignment：自动对齐插件

注释相关
DocBlockr：可以快速注释

补全相关
All Autocomplete: 这个插件扩展了其自动完成的单词列表到所有打开的文件

辅助阅读
BracketHighlighter: 类似于代码匹配，可以匹配括号，引号等符号内的范围。对代码阅读很有帮助。

文件比对

git相关
Git:  这个插件会将Git整合进你的SublimeText，使的你可以在SublimeText中运行Git命令，包括添加，提交文件，查看日志，文件注解以及其它Git功能。
GitGutter: 这是个十分有用的插件，它会在你最后一次提交Git后显示出有哪些行是被改动过的。

go相关
gosublime: go语言格式化等

目录树相关
SideBarEnhancements：可以大大加强在侧栏目录树中右键的选项

设置终端快捷键

ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/sublime



—— cesign 后记于 2018.06
</content>
      <categories>
        
          <category> 工具 </category>
        
      </categories>
      <tags>
        
          <tag> 工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>k8s架构</title>
      <url>/k8s/2018/06/06/k8s/</url>
      <content type="text">
  “k8s架构相关“


问题

最近在学习k8s，感觉学得很迷，打算弄清楚k8s的系统架构

组件(主要从master与node来说)
先来一张图解

从图中可以发现Master节点主要有etcd,kube-controller,kube-apiserver,kube-scheduler; Node包括kubelet和kube-proxy

详情请点击

</content>
      <categories>
        
          <category> k8s </category>
        
      </categories>
      <tags>
        
          <tag> 学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Docker入门</title>
      <url>/2018/03/30/docker_learn/</url>
      <content type="text">
  “Docker学习”


Docker介绍
Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。
Docker原理
Docker原理介绍：link

Docker安装
apt-get install docker
apt-get install docker.io


选择仓库（记得重启）
vim /etc/docker/daemon.json
{ &quot;registry-mirrors&quot;:[&quot;http://hub-mirror.c.163.com&quot;]}


基础命令
查看版本
docker --version


搜索可用镜像
docker search image_words


拉取镜像
docker pull image_name


删除镜像
//可能需要先停止并删除正在运行的容器
docker rmi image_id
//错误:image is referenced in multiple repositories
docker rmi respository_name


在容器中运行命令
docker run image_name cmd


查看所有容器
docker ps -a


查看运行中的容器
docker ps


删除容器
docker rm con_id
//删除所有
docker rm $(docker ps -aq)


在容器中安装程序
docker run image_name apt-get install software


保存对容器的修改（镜像）
//先查看容器ID
docker ps -l
//保存
docker commit id_start user/des_or_keyword


把保存的镜像上传到docker hub
docker tag image_name user_name/res_name
docker push user_name/res_name


检查运行中的镜像
//查看运行中的容器
docker ps
//查看容器的详细信息
docker inspect con_id


—— cesign 后记于 2018.03
</content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Docker </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>ssh实现内网穿透</title>
      <url>/lan/2018/03/05/ssh%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      <content type="text">
  “python安装问题”


问题

A主机为公网IP，B，C主机为内网IP，现在需要B连接C主机。

实现(命令)
对于服务器A:
#生成密钥，并复制到C（实现免密登陆）
&amp;gt;ssh-keygen
#复制通过scp
#在C上输入
&amp;gt;scp username@addr:~/.ssh/id_rsa.pub
&amp;gt;cat id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys


对于C
#把远程的6766端口映射到本地22端口
&amp;gt;autossh -p 22 -M 6777 -NR '*:6766:127.0.0.1:22' username@addr


然后在A上执行
#编辑/etc/ssh/sshd_config,加入 GatewayPorts yes
#重启sshd, service sshd restart
#实现B登陆到C
&amp;gt;ssh -p 6777 userb@addr


实现80端口也一样的

—— cesign 后记于 2018.03
</content>
      <categories>
        
          <category> lan </category>
        
      </categories>
      <tags>
        
          <tag> 杂 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title>Python2与python3兼容于pip同时兼容</title>
      <url>/%E5%B7%A5%E5%85%B7/2018/03/05/python2-3-install-together/</url>
      <content type="text">
  “python安装问题”


问题

安装python2于python3的pip在同一系统。

环境：

  系统 windows


实现(命令)
#python2
&amp;gt; py -2 -m pip install bs4
#python3
&amp;gt; py -3 -m pip install bs4
# 启用python2(3)
&amp;gt; py -2 (-3)



后记
快速积累

</content>
      <categories>
        
          <category> 工具 </category>
        
      </categories>
      <tags>
        
          <tag> 学习 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
