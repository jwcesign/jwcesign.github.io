<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="“基础算法”  查找算法顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 算法复杂度：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL &#x3D; 1&#x2F;n(1">
<meta property="og:type" content="article">
<meta property="og:title" content="算法">
<meta property="og:url" content="http://example.com/2018/06/28/2018-06-28-alg/index.html">
<meta property="og:site_name" content="JWCESIGN">
<meta property="og:description" content="“基础算法”  查找算法顺序查找 说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。 基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。 算法复杂度：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL &#x3D; 1&#x2F;n(1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-06-28T04:00:00.000Z">
<meta property="article:modified_time" content="2020-11-08T03:46:13.093Z">
<meta property="article:author" content="Jiang Wei">
<meta property="article:tag" content="基础算法">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2018/06/28/2018-06-28-alg/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>算法 | JWCESIGN</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">JWCESIGN</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Keep Going</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2018/06/28/2018-06-28-alg/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="Jiang Wei">
      <meta itemprop="description" content="Stay health, not be fat">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JWCESIGN">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-06-28 12:00:00" itemprop="dateCreated datePublished" datetime="2018-06-28T12:00:00+08:00">2018-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-08 11:46:13" itemprop="dateModified" datetime="2020-11-08T11:46:13+08:00">2020-11-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>“基础算法”</p>
</blockquote>
<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><ul>
<li>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表。</li>
<li>基本思想：顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</li>
<li>算法复杂度：查找成功时的平均查找长度为：（假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ；当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。</li>
<li>实现代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_intvalue</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> value, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[i] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> value = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">int</span> ind;</span><br><span class="line">  ind = find_intvalue(a, value, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ind);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><ul>
<li>说明：元素必须是有序的，如果是无序的则要先进行排序操作。</li>
<li>基本思想：也称为是折半查找，属于有序查找算法。</li>
<li>复杂度分析：最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；</li>
<li>实现代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> va, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low, high, middle;</span><br><span class="line">  low = <span class="number">0</span>;</span><br><span class="line">  high = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; va) &#123;</span><br><span class="line">      high = middle+<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[middle] == va)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> middle;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = middle<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> va = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ind;</span><br><span class="line">  ind = binary_find(<span class="built_in">array</span>,va,<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ind);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><ul>
<li>基本思想：基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。</li>
<li>复杂度分析：查找成功或者失败的时间复杂度均为O(log2(log2n))。</li>
<li>实现代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_find</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> va, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low, high, middle;</span><br><span class="line">  low = <span class="number">0</span>;</span><br><span class="line">  high = len - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">float</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    tmp = ((va - <span class="built_in">array</span>[low])*<span class="number">1.0</span> / (<span class="built_in">array</span>[high] - <span class="built_in">array</span>[low])) * (high - low);</span><br><span class="line">    middle = low + (<span class="keyword">int</span>)tmp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[middle] == va)</span><br><span class="line">      <span class="keyword">return</span> middle;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &lt; va)</span><br><span class="line">      low = middle<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>[middle] &gt; va)</span><br><span class="line">      high = middle+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> va = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ind;</span><br><span class="line">  ind = binary_find(<span class="built_in">array</span>, va, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ind);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><ul>
<li>复杂度分析：最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</li>
<li>斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。</li>
<li>实现代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MAX_SIZE = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_fibonacci</span><span class="params">(<span class="keyword">int</span> f[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_search</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> va, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low, high, middle;</span><br><span class="line">  <span class="keyword">int</span> k, i;</span><br><span class="line">  <span class="keyword">int</span> tmp[MAX_SIZE];</span><br><span class="line"></span><br><span class="line">  high = len - <span class="number">1</span>;</span><br><span class="line">  k = <span class="number">0</span>;</span><br><span class="line">  low = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> F[MAX_SIZE];</span><br><span class="line">  init_fibonacci(F);</span><br><span class="line">  <span class="keyword">while</span> (len &gt; (F[k] - <span class="number">1</span>))</span><br><span class="line">    k++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    tmp[i] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = len; i &lt; (F[k] - <span class="number">1</span>); i++)</span><br><span class="line">    tmp[i] = <span class="built_in">array</span>[high];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high)</span><br><span class="line">  &#123;</span><br><span class="line">    middle = low + F[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp[middle] == va)</span><br><span class="line">      <span class="keyword">if</span> (middle &lt; len)</span><br><span class="line">        <span class="keyword">return</span> middle;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> len - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp[middle] &lt; va)</span><br><span class="line">    &#123; </span><br><span class="line">      low = middle + <span class="number">1</span>; </span><br><span class="line">      k -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp[middle] &gt; va)</span><br><span class="line">    &#123; </span><br><span class="line">      high = middle - <span class="number">1</span>; </span><br><span class="line">      k -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> va = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> ind;</span><br><span class="line">  ind = fibonacci_search(<span class="built_in">array</span>, va, <span class="number">6</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ind);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h2><ul>
<li>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。</li>
<li>基本思想：二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。 </li>
<li>代码实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">binary_node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binary_node</span>* <span class="title">left</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">binary_node</span>* <span class="title">right</span>;</span></span><br><span class="line">&#125;bin_node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(bin_node* root,bin_node* child)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;value &gt;= root-&gt;value &amp;&amp; root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    insert_node(root-&gt;right,child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;value &lt; root-&gt;value &amp;&amp; root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    insert_node(root-&gt;left,child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;value &gt;= root-&gt;value &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;right = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (child-&gt;value &lt; root-&gt;value &amp;&amp; root-&gt;left == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    root-&gt;left = child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_tree</span><span class="params">(bin_node** root, <span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  *root = (bin_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bin_node)); </span><br><span class="line">  (*root)-&gt;value = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">  (*root)-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">  (*root)-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;size;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    bin_node* child = (bin_node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(bin_node));</span><br><span class="line">    child-&gt;value = <span class="built_in">array</span>[i];</span><br><span class="line">    child-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    child-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    insert_node(*root,child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dis_node</span><span class="params">(bin_node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dis_node(node-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;value);</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    dis_node(node-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">bin_node* <span class="title">search_node</span><span class="params">(bin_node* node, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value == node-&gt;value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &gt; node-&gt;value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> search_node(node-&gt;right,value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (value &lt; node-&gt;value)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> search_node(node-&gt;left,value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[SIZE] = &#123;<span class="number">4</span>,<span class="number">1</span>,<span class="number">45</span>,<span class="number">78</span>,<span class="number">345</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">21</span>&#125;;</span><br><span class="line">  bin_node* root = <span class="literal">NULL</span>;</span><br><span class="line">  bin_node* search_result = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> search_value;</span><br><span class="line">  create_tree(&amp;root,<span class="built_in">array</span>,SIZE);</span><br><span class="line">  dis_node(root);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\nPlease input value to search:&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;search_value);</span><br><span class="line">  search_result = search_node(root,search_value);</span><br><span class="line">  <span class="keyword">if</span> (search_result != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>)&amp;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><ul>
<li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</li>
<li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li>
<li>代码就不用实现了，因为维护代价比较大，不适用</li>
<li>原理: <a target="_blank" rel="noopener" href="https://blog.csdn.net/u014688145/article/details/67636509">link</a></li>
</ul>
<h2 id="红黑查找树"><a href="#红黑查找树" class="headerlink" title="红黑查找树"></a>红黑查找树</h2><ul>
<li>是2-3树的一种实现。</li>
<li>原理：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014688145/article/details/68489582">link</a></li>
<li>代码实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED   <span class="meta-string">&#x27;R&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK <span class="meta-string">&#x27;B&#x27;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>          key;</span><br><span class="line">    <span class="keyword">char</span>         color;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Based on CLRS algorithm, use T_Nil as a sentinel to simplify code</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>  <span class="title">T_Nil_Node</span>;</span></span><br><span class="line">Node* T_Nil = &amp;T_Nil_Node;</span><br><span class="line"></span><br><span class="line">Node* Root = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to create a new BST node</span></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *temp   = (Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    temp-&gt;key    = key;</span><br><span class="line">    temp-&gt;color  = RED;</span><br><span class="line">    temp-&gt;left   = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;right  = <span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">( Node** T, Node* x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *y  = x-&gt;right;    <span class="comment">// set y</span></span><br><span class="line">    x-&gt;right = y-&gt;left;     <span class="comment">// turn y&#x27;s left subtree into x&#x27;s right subtree&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;left != T_Nil)</span><br><span class="line">        y-&gt;left-&gt;parent = x;</span><br><span class="line">    y-&gt;parent = x-&gt;parent;  <span class="comment">// link x&#x27;s parent to y</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == T_Nil)</span><br><span class="line">        *T = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;left)</span><br><span class="line">        x-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x-&gt;parent-&gt;right = y;</span><br><span class="line">    y-&gt;left   = x;            <span class="comment">// put x on y&#x27;s left</span></span><br><span class="line">    x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Node** T, Node* y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *x  = y-&gt;left;     <span class="comment">// set x</span></span><br><span class="line">    y-&gt;left  = x-&gt;right;    <span class="comment">// turn x&#x27;s right subtree into y&#x27;s left subtree&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != T_Nil)</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line">    x-&gt;parent = y-&gt;parent;  <span class="comment">// link y&#x27;s parent to x</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == T_Nil)</span><br><span class="line">        *T = x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == y-&gt;parent-&gt;right)</span><br><span class="line">        y-&gt;parent-&gt;right = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;parent-&gt;left  = x;</span><br><span class="line">    x-&gt;right  = y;         <span class="comment">// put y on x&#x27;s right</span></span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redBlackInsertFixup</span><span class="params">(Node** Root, Node* New)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* temp;</span><br><span class="line">    <span class="keyword">while</span> (New-&gt;parent-&gt;color == RED)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (New-&gt;parent == New-&gt;parent-&gt;parent-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = New-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                New-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                temp-&gt;color = BLACK;</span><br><span class="line">                New-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                New = New-&gt;parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (New == New-&gt;parent-&gt;right)</span><br><span class="line">                &#123;</span><br><span class="line">                    New = New-&gt;parent;</span><br><span class="line">                    rotateLeft(Root, New);</span><br><span class="line">                &#125;</span><br><span class="line">                New-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                New-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rotateRight(Root, New-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            temp = New-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">            <span class="keyword">if</span> (temp-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                New-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                New-&gt;color = BLACK;</span><br><span class="line">                New-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                New = New-&gt;parent-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (New == New-&gt;parent-&gt;left)</span><br><span class="line">                &#123;</span><br><span class="line">                    New = New-&gt;parent;</span><br><span class="line">                    rotateRight(Root, New);</span><br><span class="line">                &#125;</span><br><span class="line">                New-&gt;parent-&gt;color = BLACK;</span><br><span class="line">                New-&gt;parent-&gt;parent-&gt;color = RED;</span><br><span class="line">                rotateLeft(Root, New-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Root[<span class="number">0</span>]-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redBlackInsert</span><span class="params">(Node** T, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* z =  newNode(key);</span><br><span class="line">    Node* y =  T_Nil;</span><br><span class="line">    Node* x = *T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find where to Insert new node Z into the binary search tree</span></span><br><span class="line">    <span class="keyword">while</span> (x != T_Nil) &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == T_Nil)</span><br><span class="line">        *T = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">        y-&gt;left  = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Init z as a red leaf</span></span><br><span class="line">    z-&gt;left  = T_Nil;</span><br><span class="line">    z-&gt;right = T_Nil;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure the Red-Black property is maintained</span></span><br><span class="line">    redBlackInsertFixup(T, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) (((a)&gt;(b))?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(Node* Root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Root == T_Nil)</span><br><span class="line">            h = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> leftHeight  = height(Root-&gt;left);</span><br><span class="line">            <span class="keyword">int</span> rightHeight = height(Root-&gt;right);</span><br><span class="line">            h = MAX(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != T_Nil)</span><br><span class="line">        printTree(root-&gt;left);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;key);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != T_Nil)</span><br><span class="line">        printTree(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* Root = T_Nil;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">list</span>[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//printf(&quot;%d &quot;, list[i]);</span></span><br><span class="line">        redBlackInsert(&amp;Root, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printTree(Root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><ul>
<li>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</li>
<li>算法思想：将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素。</li>
<li>性能在顺序查找和二分查找之间:</li>
<li>实现代码(这种方法不够自动):</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 16</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> key_type;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elem</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  key_type key; <span class="comment">//关键字 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//索引结构 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">index</span>         </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  key_type key; <span class="comment">//索引值 </span></span><br><span class="line">  <span class="keyword">long</span> low;     <span class="comment">//起始位置 </span></span><br><span class="line">  <span class="keyword">long</span> high;    <span class="comment">//终止位置 </span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index_search</span><span class="params">(elem e[], key_type key, <span class="keyword">int</span> n, index idx[], <span class="keyword">int</span> idx_length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = idx_length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> mid;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//采用折半查找在索引表里找到关键字所在的块</span></span><br><span class="line">  <span class="keyword">while</span>(low &lt;= high)</span><br><span class="line">  &#123;</span><br><span class="line">    mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; idx[mid].key)</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &gt; idx[mid].key)</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//采用顺序查找的方法从块中查找关键值</span></span><br><span class="line">  <span class="keyword">int</span> i = idx[mid].low;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt;= idx[mid].high &amp;&amp; e[i].key != key)</span><br><span class="line">  &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(i &gt; idx[mid].high)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  elem linelist[MAX] = &#123;</span><br><span class="line">    <span class="number">8</span>, <span class="number">20</span>, <span class="number">13</span>, <span class="number">17</span>,</span><br><span class="line">    <span class="number">40</span>, <span class="number">42</span>, <span class="number">45</span>, <span class="number">32</span>,</span><br><span class="line">    <span class="number">49</span>, <span class="number">58</span>, <span class="number">50</span>, <span class="number">52</span>,</span><br><span class="line">    <span class="number">67</span>, <span class="number">79</span>, <span class="number">78</span>, <span class="number">80</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n = <span class="keyword">sizeof</span>(linelist) / <span class="keyword">sizeof</span>(elem);</span><br><span class="line">  key_type key = <span class="number">50</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//建立索引表</span></span><br><span class="line">  index index_table[<span class="number">4</span>] = &#123;</span><br><span class="line">      &#123;<span class="number">20</span>,<span class="number">0</span>,<span class="number">3</span>&#125;, </span><br><span class="line">      &#123;<span class="number">45</span>,<span class="number">4</span>,<span class="number">7</span>&#125;, </span><br><span class="line">      &#123;<span class="number">58</span>,<span class="number">8</span>,<span class="number">11</span>&#125;, </span><br><span class="line">      &#123;<span class="number">80</span>,<span class="number">12</span>,<span class="number">15</span>&#125;&#125;; </span><br><span class="line">  <span class="keyword">int</span> idx_length = <span class="keyword">sizeof</span>(index_table) / <span class="keyword">sizeof</span>(index);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;线性表中的元素为：\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(i &lt; n) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,linelist[i].key);</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n关键字[%d]在线性表中的位置下标为[%d]&quot;</span>, key, index_search(linelist, key, n, index_table, idx_length));</span><br><span class="line">  </span><br><span class="line">  getchar();</span><br><span class="line">  system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HASH查找"><a href="#HASH查找" class="headerlink" title="HASH查找"></a>HASH查找</h2><ul>
<li>通过函数实现KV查找,用空间代替时间</li>
<li>HASH构造方法: <a target="_blank" rel="noopener" href="https://blog.csdn.net/tanggao1314/article/details/51457585">link</a></li>
</ul>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ul>
<li>动态规划算法的核心就是记住已经解决过的子问题的解。</li>
<li>两种方法: ①自顶向下的备忘录法 ②自底向上。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013309870/article/details/75193592">讲解</a></li>
</ul>
<h2 id="自顶向下的备忘录法"><a href="#自顶向下的备忘录法" class="headerlink" title="自顶向下的备忘录法"></a>自顶向下的备忘录法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> *Memo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Memo[n]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> Memo[n];</span><br><span class="line">    <span class="comment">//如果已经求出了fib（n）的值直接返回，否则将求出的值保存在Memo备忘录中。               </span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">2</span>)</span><br><span class="line">        Memo[n]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        Memo[n]=fib( n<span class="number">-1</span>,Memo)+fib(n<span class="number">-2</span>,Memo);  </span><br><span class="line">    <span class="keyword">return</span> Memo[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> *Memo=<span class="keyword">new</span> <span class="keyword">int</span>(n+<span class="number">1</span>);        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">         Memo[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(n, Memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Fibonacci(<span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备忘录法也是比较好理解的，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。比如上面的递归树中在计算fib（6）的时候先计算fib（5），调用fib（5）算出了fib（4）后，fib（6）再调用fib（4）就不会在递归fib（4）的子树了，因为fib（4）的值已经保存在Memo[4]中。</p>
<h2 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> Memo_i_2=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> Memo_i_1=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> Memo_i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    Memo_i=Memo_i_2+Memo_i_1;</span><br><span class="line">    Memo_i_2=Memo_i_1;</span><br><span class="line">    Memo_i_1=Memo_i;</span><br><span class="line">  &#125;       </span><br><span class="line">  <span class="keyword">return</span> Memo_i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用自底向上的动态规划方法要比备忘录方法好。 </p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="钢条切割"><a href="#钢条切割" class="headerlink" title="钢条切割"></a>钢条切割</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> q=<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        m = cut(p,n-i);</span><br><span class="line">        <span class="keyword">if</span> (q&lt;(p[i<span class="number">-1</span>]+m))</span><br><span class="line">            q = p[i<span class="number">-1</span>]+m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p[]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cut(p, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把每个子最优解返回到父最优解</p>
<ul>
<li>备忘</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> *r, <span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (r[n<span class="number">-1</span>] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> r[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m = p[i<span class="number">-1</span>]+cut(r,p,n-i);</span><br><span class="line">        <span class="keyword">if</span> (m&gt;q)</span><br><span class="line">            q = m;</span><br><span class="line">    &#125;</span><br><span class="line">    r[n<span class="number">-1</span>] = q;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut_pre</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        r[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> cut(r, p, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每长度对应的价值</span></span><br><span class="line">    <span class="keyword">int</span> p[]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 9为长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cut_pre(p, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自底向上</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> *p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>(n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> q, m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        r[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            m = p[j<span class="number">-1</span>]+r[i-j];</span><br><span class="line">            <span class="keyword">if</span> (m&gt;q)</span><br><span class="line">                q = m;</span><br><span class="line">        &#125;</span><br><span class="line">        r[i] = q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每长度对应的价值</span></span><br><span class="line">    <span class="keyword">int</span> p[]=&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">17</span>,<span class="number">17</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">30</span>&#125;;</span><br><span class="line">    <span class="comment">// 9为长度</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cut(p, <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过求解最优子问题来解决副问题的最优解</p>
<h2 id="在什么地方用？"><a href="#在什么地方用？" class="headerlink" title="在什么地方用？"></a>在什么地方用？</h2><h3 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h3><p>用动态规划求解最优化问题的第一步就是刻画最优解的结构，如果一个问题的解结构包含其子问题的最优解，就称此问题具有最优子结构性质。因此，某个问题是否适合应用动态规划算法，它是否具有最优子结构性质是一个很好的线索。使用动态规划算法时，用子问题的最优解来构造原问题的最优解。因此必须考查最优解中用到的所有子问题。</p>
<h3 id="重叠子问题"><a href="#重叠子问题" class="headerlink" title="重叠子问题"></a>重叠子问题</h3><p>在斐波拉契数列和钢条切割结构图中，可以看到大量的重叠子问题，比如说在求fib（6）的时候，fib（2）被调用了5次，在求cut（4）的时候cut（0）被调用了4次。如果使用递归算法的时候会反复的求解相同的子问题，不停的调用函数，而不是生成新的子问题。如果递归算法反复求解相同的子问题，就称为具有重叠子问题（overlapping subproblems）性质。在动态规划算法中使用数组来保存子问题的解，这样子问题多次求解的时候可以直接查表不用调用函数递归。</p>
<h2 id="动态规划的经典模型"><a href="#动态规划的经典模型" class="headerlink" title="动态规划的经典模型"></a>动态规划的经典模型</h2><h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p>线性模型的是动态规划中最常用的模型，上文讲到的钢条切割问题就是经典的线性模型，这里的线性指的是状态的排布是呈线性的。</p>
<p>例：在一个夜黑风高的晚上，有n（n &lt;= 50）个小朋友在桥的这边，现在他们需要过桥，但是由于桥很窄，每次只允许不大于两人通过，他们只有一个手电筒，所以每次过桥的两个人需要把手电筒带回来，i号小朋友过桥的时间为T[i]，两个人过桥的总时间为二者中时间长者。问所有小朋友过桥的总时间最短是多少。</p>
<p><em>分析</em>:<br>我们先将所有人按花费时间递增进行排序，假设前i个人过河花费的最少时间为opt[i]，那么考虑前i-1个人过河的情况，即河这边还有1个人，河那边有i-1个人，并且这时候手电筒肯定在对岸，所以opt[i] = opt[i-1] + a[1] + a[i]        (让花费时间最少的人把手电筒送过来，然后和第i个人一起过河)<br>如果河这边还有两个人，一个是第i号，另外一个无所谓，河那边有i-2个人，并且手电筒肯定在对岸，所以opt[i] = opt[i-2] + a[1] + a[i] + 2<em>a[2]    (让花费时间最少的人把电筒送过来，然后第i个人和另外一个人一起过河，由于花费时间最少的人在这边，所以下一次送手电筒过来的一定是花费次少的，送过来后花费最少的和花费次少的一起过河，解决问题),所以 opt[i] = min{opt[i-1] + a[1] + a[i] , opt[i-2] + a[1] + a[i] + 2</em>a[2] }</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">go</span><span class="params">(<span class="keyword">int</span> *cost_time, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *r = <span class="keyword">new</span> <span class="keyword">int</span>(n);</span><br><span class="line">    <span class="keyword">int</span> m,mb;</span><br><span class="line">    r[<span class="number">0</span>] = cost_time[<span class="number">0</span>];</span><br><span class="line">    r[<span class="number">1</span>] = cost_time[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m = r[i<span class="number">-1</span>]+cost_time[<span class="number">0</span>]+cost_time[i];</span><br><span class="line">        mb = r[i<span class="number">-2</span>]+cost_time[<span class="number">0</span>]+cost_time[i]+<span class="number">2</span>*cost_time[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (m&gt;mb)</span><br><span class="line">            r[i] = mb;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r[n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每个人过桥花费的时间</span></span><br><span class="line">    <span class="keyword">int</span> cost_time[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; go(cost_time,<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="区间模型"><a href="#区间模型" class="headerlink" title="区间模型"></a>区间模型</h3><p>区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i, j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。</p>
<p>例:给定一个长度为n（n &lt;= 1000）的字符串A，求插入最少多少个字符使得它变成一个回文串。 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cacu</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> re[<span class="number">6</span>][<span class="number">6</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *a = <span class="string">&quot;cccbccc&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> re[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cacu(a, <span class="number">0</span>, <span class="number">6</span>, re) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cacu</span><span class="params">(<span class="keyword">char</span> *a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> re[<span class="number">6</span>][<span class="number">6</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="keyword">if</span> (start+<span class="number">1</span> &gt;= end || start &gt;= end<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[start] == a[end])</span><br><span class="line">        <span class="keyword">return</span> cacu(a, start+<span class="number">1</span>, end<span class="number">-1</span>, re);</span><br><span class="line">    m = cacu(a, start+<span class="number">1</span>, end, re);</span><br><span class="line">    n = cacu(a, start, end<span class="number">-1</span>, re);</span><br><span class="line">    <span class="keyword">if</span> (m&gt;n)</span><br><span class="line">        re[start][end] = n+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        re[start][end] = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> re[start][end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>给定背包的大小，给定物品的价值和重量，确定能够装下的最大价值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">15</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v[N]=&#123;<span class="number">0</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> w[N]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">int</span> m[N][N];</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">6</span>,c=<span class="number">12</span>;</span><br><span class="line">  <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=c;j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">        m[i][j]=max(m[i<span class="number">-1</span>][j],m[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        m[i][j]=m[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; m[n][c] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="字符串查找算法"><a href="#字符串查找算法" class="headerlink" title="字符串查找算法"></a>字符串查找算法</h2><h3 id="传统的字符串匹配算法"><a href="#传统的字符串匹配算法" class="headerlink" title="传统的字符串匹配算法:"></a>传统的字符串匹配算法:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span> t[],<span class="keyword">char</span> p[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">strlen</span>(t);</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="keyword">int</span> i,j,k;<span class="comment">//k:匹配串下标，j：模式串下标</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        i = k;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p[j]==t[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;在%d处匹配\n&quot;</span>,k);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a><em>KMP</em>算法</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">详解</a></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;T, <span class="keyword">const</span> <span class="built_in">string</span> &amp;P)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (P.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pi</span><span class="params">(P.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; pi.size() &lt;&lt; <span class="string">&quot;---&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>; i &lt; P.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &amp;&amp; P[k] != P[i]) k = pi[k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (P[k] == P[i]) ++k;</span><br><span class="line">    pi[i] = k;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;pi.size();i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pi[i];</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, k = <span class="number">0</span>; i &lt; T.size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &amp;&amp; P[k] != T[i]) k = pi[k - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (P[k] == T[i]) ++k;</span><br><span class="line">    <span class="keyword">if</span> (k == P.size()) <span class="keyword">return</span> i - k + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">string</span> T = <span class="string">&quot;abcdefgadbcabcd&quot;</span>;</span><br><span class="line">  <span class="built_in">string</span> P = <span class="string">&quot;ccadaddd&quot;</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; kmp(T, P);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/" rel="tag"># 基础算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/2018/06/28/2018-08-12-cmake/" rel="next" title="cmake学习">
      cmake学习 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-number">1.1.</span> <span class="nav-text">顺序查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.2.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-number">1.3.</span> <span class="nav-text">插值查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="nav-number">1.4.</span> <span class="nav-text">斐波那契查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9F%A5%E6%89%BE"><span class="nav-number">1.5.</span> <span class="nav-text">二叉树查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">1.6.</span> <span class="nav-text">2-3查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%A2%E9%BB%91%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="nav-number">1.7.</span> <span class="nav-text">红黑查找树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-number">1.8.</span> <span class="nav-text">分块查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HASH%E6%9F%A5%E6%89%BE"><span class="nav-number">1.9.</span> <span class="nav-text">HASH查找</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">2.</span> <span class="nav-text">动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%AB%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">含义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E7%9A%84%E5%A4%87%E5%BF%98%E5%BD%95%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">自顶向下的备忘录法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A"><span class="nav-number">2.3.</span> <span class="nav-text">自底向上</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98"><span class="nav-number">2.4.</span> <span class="nav-text">例题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2"><span class="nav-number">2.4.1.</span> <span class="nav-text">钢条切割</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E7%94%A8%EF%BC%9F"><span class="nav-number">2.5.</span> <span class="nav-text">在什么地方用？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">2.5.1.</span> <span class="nav-text">最优子结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98"><span class="nav-number">2.5.2.</span> <span class="nav-text">重叠子问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.6.</span> <span class="nav-text">动态规划的经典模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.6.1.</span> <span class="nav-text">线性模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BA%E9%97%B4%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.6.2.</span> <span class="nav-text">区间模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">2.6.3.</span> <span class="nav-text">01背包问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">3.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">字符串查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">传统的字符串匹配算法:</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">KMP算法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Wei"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">Jiang Wei</p>
  <div class="site-description" itemprop="description">Stay health, not be fat</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">[object Object]</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
